/**
 * Generated by Verge3D Puzzles v.2.14.0 pre2
 * Mon Sep 02 2019 23:48:01 GMT+0200 (Central European Summer Time)
 * Prefer not editing this file as your changes may get overridden once Puzzles are saved.
 * Check out https://www.soft8soft.com/docs/manual/en/introduction/Using-JavaScript.html
 * for the information on how to add your own JavaScript to Verge3D apps.
 */

'use strict';

(function() {

// global variables/constants used by puzzles' functions
var _pGlob = {};

_pGlob.objCache = {};
_pGlob.fadeAnnotations = true;
_pGlob.objClickCallbacks = [];
_pGlob.pickedObject = '';
_pGlob.objHoverCallbacks = [];
_pGlob.hoveredObject = '';
_pGlob.objMovementInfos = {};
_pGlob.objDragOverCallbacks = [];
_pGlob.objDragOverInfoByBlock = {}
_pGlob.dragMoveOrigins = {};
_pGlob.dragScaleOrigins = {};
_pGlob.mediaElements = {};
_pGlob.loadedFiles = {};
_pGlob.loadedFile = '';
_pGlob.animMixerCallbacks = [];
_pGlob.arHitPoint = new v3d.Vector3(0, 0, 0);
_pGlob.states = [];
_pGlob.percentage = 0;
_pGlob.animateParamUpdate = null;
_pGlob.openedFile = '';
_pGlob.xrSessionAcquired = false;
_pGlob.xrSessionCallbacks = [];
_pGlob.screenCoords = new v3d.Vector2();

_pGlob.AXIS_X = new v3d.Vector3(1, 0, 0);
_pGlob.AXIS_Y = new v3d.Vector3(0, 1, 0);
_pGlob.AXIS_Z = new v3d.Vector3(0, 0, 1);
_pGlob.MIN_DRAG_SCALE = 10e-4;

_pGlob.vec2Tmp = new v3d.Vector2();
_pGlob.vec2Tmp2 = new v3d.Vector2();
_pGlob.vec3Tmp = new v3d.Vector3();
_pGlob.vec3Tmp2 = new v3d.Vector3();
_pGlob.quatTmp = new v3d.Quaternion();
_pGlob.quatTmp2 = new v3d.Quaternion();
_pGlob.mat4Tmp = new v3d.Matrix4();
_pGlob.planeTmp = new v3d.Plane();
_pGlob.raycasterTmp = new v3d.Raycaster();
_pGlob.timers = {};

var _pPhysics = {};

_pPhysics.syncList = [];

// internal info
_pPhysics.collisionData = [];

// goes to collision callback
_pPhysics.collisionInfo = {
    objectA: '',
    objectB: '',
    distance: 0,
    positionOnA: [0, 0, 0],
    positionOnB: [0, 0, 0],
    normalOnB: [0, 0, 0]
};

var PL = v3d.PL = v3d.PL || {};

PL.legacyMode = false;

PL.execInitPuzzles = function() {

    var _initGlob = {};
    _initGlob.percentage = 0;
    _initGlob.output = {
        initOptions: {
            fadeAnnotations: true,
            useBkgTransp: false,
            preserveDrawBuf: false,
            useCompAssets: false,
            useFullscreen: true,
            useCustomPreloader: false,
            preloaderStartCb: function() {},
            preloaderProgressCb: function() {},
            preloaderEndCb: function() {},
        }
    }
    // initSettings puzzle
_initGlob.output.initOptions.fadeAnnotations = true;
_initGlob.output.initOptions.useBkgTransp = false;
_initGlob.output.initOptions.preserveDrawBuf = false;
_initGlob.output.initOptions.useCompAssets = true;
_initGlob.output.initOptions.useFullscreen = true;

    return _initGlob.output;
}

PL.init = function(appInstance, initOptions) {

initOptions = initOptions || {};

if ('fadeAnnotations' in initOptions) {
    _pGlob.fadeAnnotations = initOptions.fadeAnnotations;
}
var hunter_loaded, amazon_loaded, stat_change_char, camDir, stat_view_TPS, charDir, stat_view_FPS, person_position, stat_view_orbit, is_selected_char_hunter, is_selected_char_amazon, move_steps, pos_cam_x, person_position_next, pos_cam_y, person_position_prev, orbit_prepos_x, start_game, orbit_prepos_y, stat_jump, stat_mobile_device, stat_move_right, score, stat_move_left, time, stat_mov_front, emptys_witch_fruits, stat_move_back, emptys_distance, stat_giro_left, fruits_count, stat_giro_right, fruits_amount, stat_attack, fruits_max, char_velocity_speed, stat_idle, cam_rotation_x, i, cam_rotation_y, selectable_list_chars, cam_rotation_z, stat_bajando_fps_jump, pick_loaded, stat_restablecido_fps_jump, person_position_Z, current_level_loaded, pos_cam_z, levels, stat_previ_storage_clear, level_path, current_level_index, current_level, time_full, final_level, score_min_for_nex_level, current_score, current_lang, person_position_reset, cam_rot_reset, current_char, stat_storage_previ, casset_loaded, scene_change_char_loaded, stat_game_paused, stat_game_finised, scenes_change_char, list_buildings, sound_list_temes, person_rotation_z, person_position_current, view, stat_cheats_menu, stat_view, j, emptys_to_check, current_pos_Z_fps, stat_en_pte, cam_pos_z_max, cam_pos_z_min, person_position_X, person_position_Y;


// utility function envoked by almost all V3D-specific puzzles
// process object input, which can be either single obj or array of objects, or a group
function retrieveObjectNames(objNames) {
    var acc = [];
    retrieveObjectNamesAcc(objNames, acc);
    return acc;
}

function retrieveObjectNamesAcc(currObjNames, acc) {
    if (typeof currObjNames == "string") {
        acc.push(currObjNames);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "GROUP") {
        var newObj = getObjectNamesByGroupName(currObjNames[1]);
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames) && currObjNames[0] == "ALL_OBJECTS") {
        var newObj = getAllObjectNames();
        for (var i = 0; i < newObj.length; i++)
            acc.push(newObj[i]);
    } else if (Array.isArray(currObjNames)) {
        for (var i = 0; i < currObjNames.length; i++)
            retrieveObjectNamesAcc(currObjNames[i], acc);
    }
}


// utility function envoked by almost all V3D-specific puzzles
// find first occurence of the object by its name
function getObjectByName(objName) {
    var objFound;
    var runTime = typeof _pGlob != "undefined";
    objFound = runTime ? _pGlob.objCache[objName] : null;
    if (objFound && objFound.name == objName)
        return objFound;
    appInstance.scene.traverse(function(obj) {
        if (!objFound && notIgnoredObj(obj) && (obj.name == objName)) {
            objFound = obj;
            if (runTime)
                _pGlob.objCache[objName] = objFound;
        }
    });
    return objFound;
}

// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects which belong to the group
function getObjectNamesByGroupName(targetGroupName) {
    var objNameList = [];
    appInstance.scene.traverse(function(obj){
        if (notIgnoredObj(obj)) {
            var groupNames = obj.groupNames;
            if (!groupNames)
                return;
            for (var i = 0; i < groupNames.length; i++) {
                var groupName = groupNames[i];
                if (groupName == targetGroupName) {
                    objNameList.push(obj.name);
                }
            }
        }
    });
    return objNameList;
}

// utility function envoked by almost all V3D-specific puzzles
// filter off some non-mesh types
function notIgnoredObj(obj) {
    return (obj.type != "Scene" && obj.type != "AmbientLight" &&
            obj.name != "" && !(obj.isMesh && obj.isMaterialGeneratedMesh));
}

// utility function envoked by almost all V3D-specific puzzles
// retrieve all objects on the scene
function getAllObjectNames() {
    var objNameList = [];
    appInstance.scene.traverse(function(obj) {
        if (notIgnoredObj(obj))
            objNameList.push(obj.name)
    });
    return objNameList;
}

/**
 * Blender/Max to Verge3D
 */
function swizzleValueSign(newAxis, value) {
    newAxis = newAxis.toLowerCase();

    if (newAxis == 'z') {
        if (typeof value == 'number')
            return -value
        else if (typeof value == 'string' && value != '' && value != "''" && value != '""')
            return String(-Number(value));
        else
            return value;
    } else
        return value;
}

/**
 * Blender/Max to Verge3D
 */
function swizzleVec3(vec, isScale) {

    var dest = []

    dest[0] = vec[0];
    dest[1] = vec[2];
    dest[2] = isScale ? vec[1] : swizzleValueSign('z', vec[1])

    return dest;
}

/**
 * mesh or multi-material object
 */
function isMeshObj(obj) {
    if (obj.isMesh)
        return true;

    for (var i = 0; i < obj.children.length; i++) {
        var child = obj.children[i];
        if (child.isMesh && child.isMaterialGeneratedMesh)
            return true;
    }

    return false;
}



// show and hide puzzles
function changeVis(objNames, bool) {
    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;
    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i]
        if (!objName)
            continue;
        var obj = getObjectByName(objName);
        if (!obj)
            continue;
        obj.visible = bool;
    }
}



// featureAvailable puzzle
function featureAvailable(feature) {

    var userAgent = window.navigator.userAgent;
    var platform = window.navigator.platform;

    switch (feature) {
    case 'LINUX':
        return /Linux/.test(platform);
    case 'WINDOWS':
        return ['Win32', 'Win64', 'Windows', 'WinCE'].indexOf(platform) !== -1;
    case 'MACOS':
        return ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'].indexOf(platform) !== -1;
    case 'IOS':
        return (/iPad|iPhone|iPod/.test(userAgent) && !window.MSStream);
    case 'ANDROID':
        return /Android/i.test(userAgent);
    case 'MOBILE':
        return /Android|webOS|iPhone|iPad|iPod|BlackBerry/i.test(userAgent);

    case 'CHROME':
        // Chromium based
        return (!!window.chrome && !/Edge/.test(navigator.userAgent));
    case 'FIREFOX':
        return /Firefox/.test(navigator.userAgent);
    case 'IE':
        return /Trident/.test(navigator.userAgent);
    case 'EDGE':
        return /Edge/.test(navigator.userAgent);
    case 'SAFARI':
        return (/Safari/.test(navigator.userAgent) && !/Chrome/.test(navigator.userAgent));

    case 'TOUCH':
        return !!(('ontouchstart' in window) || window.DocumentTouch && document instanceof DocumentTouch);
    case 'RETINA':
        return window.devicePixelRatio >= 2;
    case 'HDR':
        return appInstance.useHDR;
    case 'WEBGL2':
        var canvas = document.createElement('canvas');
        var gl = canvas.getContext('webgl2')
        return !!gl;
    case 'WOOCOMMERCE':
        return !!window.parent.v3d_woocommerce_change_param;
    default:
        return false;
    }

}



// utility functions envoked by the HTML puzzles
function getElements(ids, isParent) {
    var elems = [];
    if (Array.isArray(ids) && ids[0] != 'WINDOW' && ids[0] != 'DOCUMENT' && ids[0] != 'BODY') {
        for (var i = 0; i < ids.length; i++)
            elems.push(getElement(ids[i], isParent));
    } else {
        elems.push(getElement(ids, isParent));
    }
    return elems;
}

function getElement(id, isParent) {
    var elem;
    if (Array.isArray(id) && id[0] == 'WINDOW') {
        if (isParent)
            elem = parent;
        else
            elem = window;
    } else if (Array.isArray(id) && id[0] == 'DOCUMENT') {
        if (isParent)
            elem = parent.document;
        else
            elem = document;
    } else if (Array.isArray(id) && id[0] == 'BODY') {
        if (isParent)
            elem = parent.document.body;
        else
            elem = document.body;
    } else {
        if (isParent)
            elem = parent.document.getElementById(id);
        else
            elem = document.getElementById(id);
    }
    return elem;
}



// setHTMLElemStyle puzzle
function setHTMLElemStyle(prop, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem || !elem.style)
            continue;
        elem.style[prop] = value;
    }
}



// animation puzzles
function getSceneByAction(action) {
    var root = action.getRoot();
    var scene = root.type == "Scene" ? root : null;
    root.traverseAncestors(function(ancObj) {
        if (ancObj.type == "Scene") {
            scene = ancObj;
        }
    });
    return scene;
}



// animation puzzles
function getSceneAnimFrameRate(scene) {
    if (scene && "v3d" in scene.userData && "animFrameRate" in scene.userData.v3d) {
        return scene.userData.v3d.animFrameRate;
    }
    return 24;
}



var initAnimationMixer = function() {

    function onMixerFinished(e) {
        var cb = _pGlob.animMixerCallbacks;
        var found = [];
        for (var i = 0; i < cb.length; i++) {
            if (cb[i][0] == e.action) {
                cb[i][0] = null; // desactivate
                found.push(cb[i][1]);
            }
        }
        for (var i = 0; i < found.length; i++) {
            found[i]();
        }
    }

    return function initAnimationMixer() {
        if (appInstance.mixer && !appInstance.mixer.hasEventListener('finished', onMixerFinished))
            appInstance.mixer.addEventListener('finished', onMixerFinished);
    };

}();



// animation puzzles
function operateAnimation(operation, animations, from, to, loop, speed, callback, isPlayAnimCompat, rev) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];

    function processAnimation(animName) {
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (!action)
            return;
        switch (operation) {
        case 'PLAY':
            if (!action.isRunning()) {
                action.reset();
                if (loop && (loop != "AUTO"))
                    action.loop = v3d[loop];
                var scene = getSceneByAction(action);
                var frameRate = getSceneAnimFrameRate(scene);

                // compatibility reasons: deprecated playAnimation puzzles don't
                // change repetitions
                if (!isPlayAnimCompat) {
                    action.repetitions = Infinity;
                }

                var timeScale = Math.abs(parseFloat(speed));
                if (rev)
                    timeScale *= -1;

                action.timeScale = timeScale;
                action.timeStart = from !== null ? from/frameRate : 0;
                if (to !== null) {
                    action.getClip().duration = to/frameRate;
                } else {
                    action.getClip().resetDuration();
                }
                action.time = timeScale >= 0 ? action.timeStart : action.getClip().duration;

                action.paused = false;
                action.play();

                // push unique callbacks only
                var callbacks = _pGlob.animMixerCallbacks;
                var found = false;

                for (var j = 0; j < callbacks.length; j++)
                    if (callbacks[j][0] == action && callbacks[j][1] == callback)
                        found = true;

                if (!found)
                    _pGlob.animMixerCallbacks.push([action, callback]);
            }
            break;
        case 'STOP':
            action.stop();

            // remove callbacks
            var callbacks = _pGlob.animMixerCallbacks;
            for (var j = 0; j < callbacks.length; j++)
                if (callbacks[j][0] == action) {
                    callbacks.splice(j, 1);
                    j--
                }

            break;
        case 'PAUSE':
            action.paused = true;
            break;
        case 'RESUME':
            action.paused = false;
            break;
        case 'SET_FRAME':
            var frameRate = getSceneAnimFrameRate(scene);
            action.time = from ? from/frameRate : 0;
            action.play();
            action.paused = true;
            break;
        }
    }

    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (animName)
            processAnimation(animName);
    }

    initAnimationMixer();
}



// setHTMLElemAttribute puzzle
function setHTMLElemAttribute(attr, value, ids, isParent) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem[attr] = value;
    }
}



// snapBody puzzle
function snapBody(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;

    var obj = getObjectByName(objName);
    var targetObj = getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.obj == obj) {

            // snap verge3d object itself
            obj.copyTransform(targetObj);

            // snap body
            var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
            var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

            _pPhysics.transTmp.setIdentity();
            _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

            syncData.body.setWorldTransform(_pPhysics.transTmp);

        }
    }
}


/**
 * Describe this function...
 */
function main_game() {
  stat_change_char = 0;
  load_hunter_char2();
  if (is_selected_char_hunter) {
    changeVis('select_h', false);
    changeVis('select_a', false);
    load_hunter_char();
  } else if (is_selected_char_amazon) {
    changeVis('select_a', false);
    changeVis('select_h', false);
    load_amazon_char();
  }
  hide_body_amazon();
  hide_body_hunter();
  hide_body_hunter_fps();
  if (featureAvailable('MOBILE')) {
    stat_mobile_device = 1;
    console.log('estamos en un dispositivo movil');
  }
  show_controls();
  hide_button_startout_game();
  console.log('desactivamos pointerlock realmente ya lo esta activado o visible y z-index 9999 a no ser que iniciemos en mobil');
  show_controls();
  show_main_game_stats();
  show_pick_objs();
  show_game_menu_calling();
  setHTMLElemStyle('display', 'block', 'fullscreen_button', true);
  time = time_full;

  operateAnimation('STOP', 'hunter_rig', null, null, 'AUTO', 1,
          function() {}, undefined, false);

      setHTMLElemAttribute('innerHTML', time, 'Time', true);
  stat_idle = 0;
  start_game = 1;
  stat_view_orbit = 1;
  console.log('deberia haberse reorientado y cambiar a TPS');
  snapBody('hunter_physic', 'person_pos_0');
}

/**
 * Describe this function...
 */
function list_var_main2() {
  camDir = 0;
  charDir = 0;
  person_position = 0;
  move_steps = 0;
  person_position_next = 0;
  person_position_prev = 0;
  start_game = 0;
  stat_jump = 0;
  stat_move_right = 0;
  stat_move_left = 0;
  stat_mov_front = 0;
  stat_move_back = 0;
  stat_giro_left = 0;
  stat_giro_right = 0;
  stat_attack = 0;
  char_velocity_speed = 0;
  stat_idle = 0;
  cam_rotation_x = 0;
  cam_rotation_y = 0;
  cam_rotation_z = 3;
  stat_bajando_fps_jump = 0;
  stat_restablecido_fps_jump = 1;
  person_position_Z = 0;
  pos_cam_z = 0;
  stat_previ_storage_clear = 0;
}

/**
 * Describe this function...
 */
function list_var_main1() {
  stat_view_TPS = 0;
  stat_view_FPS = 0;
  stat_view_orbit = 0;
  pos_cam_x = 0;
  pos_cam_y = 0;
  orbit_prepos_x = 0;
  orbit_prepos_y = 0;
  stat_mobile_device = 0;
  score = 0;
  time = 0;
  emptys_witch_fruits = [];
  emptys_distance = [];
  fruits_count = [0, 0, 0, 0];
  fruits_amount = 0;
  fruits_max = 0;
  is_selected_char_amazon = 0;
  is_selected_char_hunter = 0;
  for (i = 1; i <= 11; i++) {
    emptys_witch_fruits[i] = 'Empty';
  }
  selectable_list_chars = [];
  amazon_loaded = 0;
  hunter_loaded = 0;
  pick_loaded = 0;
  current_level_loaded = 0;
  levels = ['level_city', 'level_campo'];
  level_path = ['assets/builds/terrain/terrain.gltf', 'assets/building/city2/city2_base.gltf.xz'];
  current_level_index = 0;
  current_level = levels[current_level_index];
  final_level = 0;
  final_level = levels.length - 1;
  console.log('indice del ultimo nivel sera ');
  console.log(final_level);
  score_min_for_nex_level = 24;
  time_full = 160;
  current_score = 0;
  current_lang = 'en';
  person_position_reset = 0;
  cam_rot_reset = 0;
  current_char = 'hunter';
  stat_storage_previ = 0;
  stat_change_char = 0;
  casset_loaded = 0;
  scene_change_char_loaded = 1;
  stat_game_paused = 0;
  stat_game_finised = 0;
  start_game = 0;
  update_app_vars();
}

/**
 * Describe this function...
 */
function load_hunter_char() {
}


// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function initObjectPicking(callback, eventType, mouseDownUseTouchStart) {

    var elem = appInstance.container;
    elem.addEventListener(eventType, pickListener);
    if (eventType == "mousedown") {
        var touchEventName = mouseDownUseTouchStart ? "touchstart" : "touchend";
        elem.addEventListener(touchEventName, pickListener);
    }

    var raycaster = new v3d.Raycaster();
    function pickListener(event) {
        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
        raycaster.setFromCamera(_pGlob.screenCoords, appInstance.camera);
        var objList = [];
        appInstance.scene.traverse(function(obj){objList.push(obj);});
        var intersects = raycaster.intersectObjects(objList);
        if (intersects.length > 0) {
            var obj = intersects[0].object;
            callback(obj, event);
        } else {
            callback(null, event);
        }
    }
}

// utility function used by the whenDraggedOver puzzles
function fireObjectPickingCallbacks(objName, source, index, cbParam) {
    for (var i = 0; i < source.length; i++) {
        var cb = source[i];
        if (objectsIncludeObj([cb[0]], objName)) {
            cb[index](cbParam);
        }
    }
}

function objectsIncludeObj(objNames, testedObjName) {
    if (!testedObjName) return false;

    for (var i = 0; i < objNames.length; i++) {
        if (testedObjName == objNames[i]) {
            return true;
        } else {
            // also check children which are auto-generated for multi-material objects
            var obj = getObjectByName(objNames[i]);
            if (obj && obj.type == "Group") {
                for (var j = 0; j < obj.children.length; j++) {
                    if (testedObjName == obj.children[j].name) {
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

// utility function used by the whenClicked, whenHovered and whenDraggedOver puzzles
function getPickedObjectName(obj) {
    // auto-generated from a multi-material object, use parent name instead
    if (obj.isMesh && obj.isMaterialGeneratedMesh && obj.parent) {
        return obj.parent.name;
    } else {
        return obj.name;
    }
}



// createPhysicsBody puzzle
function createPhysicsBody(type, objNames, shape, mass) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        if (type == 'STATIC' || type == 'KINEMATIC')
            mass = 0;

        switch (shape) {
        case 'BOX':

            var size = new v3d.Vector3(1, 1, 1);

            if (obj.geometry) {
                if (obj.geometry.boundingBox == null)
                    obj.geometry.computeBoundingBox();

                obj.geometry.boundingBox.getSize(size);
            }

            var geometry = new Ammo.btBoxShape(new Ammo.btVector3(size.x * 0.5, size.y * 0.5, size.z * 0.5));

            //geometry.setMargin(0.001);

            break;
        case 'SPHERE':

            var radius = 1;

            if (obj.geometry) {
                if (obj.geometry.boundingSphere === null)
                    obj.geometry.computeBoundingSphere();

                radius = obj.geometry.boundingSphere.radius;
            }

            var geometry = new Ammo.btSphereShape(radius);

            break;
        case 'MESH':

            if (!obj.geometry || !obj.isMesh) {
                console.error('create physics body: incorrect mesh object');
                var geometry = new Ammo.btEmptyShape();
                break;
            }

            var positions = obj.geometry.attributes.position.array;

            if (type == 'DYNAMIC') {

                var geometry = new Ammo.btConvexHullShape();

                for (var i = 0; i < positions.length; i+=3) {
                    var x = positions[i];
                    var y = positions[i+1];
                    var z = positions[i+2];

                    var v = new Ammo.btVector3(x, y, z);

                    geometry.addPoint(v);

                    Ammo.destroy(v);
                }

            } else {
                var indices = obj.geometry.index.array;

                var triIdxVertArray = new Ammo.btTriangleMesh();

                for (var i = 0; i < indices.length; i+=3) {

                    var i1 = indices[i];
                    var i2 = indices[i+1];
                    var i3 = indices[i+2];

                    var v1 = new Ammo.btVector3(positions[3*i1], positions[3*i1+1], positions[3*i1+2]);
                    var v2 = new Ammo.btVector3(positions[3*i2], positions[3*i2+1], positions[3*i2+2]);
                    var v3 = new Ammo.btVector3(positions[3*i3], positions[3*i3+1], positions[3*i3+2]);

                    triIdxVertArray.addTriangle(v1, v2, v3, false);

                    Ammo.destroy(v1);
                    Ammo.destroy(v2);
                    Ammo.destroy(v3);
                }

                var geometry = new Ammo.btBvhTriangleMeshShape(triIdxVertArray, true);

            }

            break;
        }

        var pos = obj.getWorldPosition(_pGlob.vec3Tmp);
        var quat = obj.getWorldQuaternion(_pGlob.quatTmp);

        var transform = new Ammo.btTransform();
        transform.setIdentity();
        transform.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
        transform.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));
        var motionState = new Ammo.btDefaultMotionState(transform);

        var localInertia = new Ammo.btVector3(0, 0, 0);
        geometry.calculateLocalInertia(mass, localInertia);

        var rbInfo = new Ammo.btRigidBodyConstructionInfo(mass, motionState, geometry, localInertia);
        var body = new Ammo.btRigidBody(rbInfo);

        if (type == 'KINEMATIC') {
            var CF_KINEMATIC_OBJECT = 2;
            body.setCollisionFlags(body.getCollisionFlags() | CF_KINEMATIC_OBJECT);
        }

        _pPhysics.world.addRigidBody(body);

        //body.setDamping(0.1, 0.1);

        _pPhysics.syncList.push({
            obj: obj,
            body: body,
            type: type
        });

    });


}



// physicsBodyParams puzzle
function physicsBodyParams(objNames, friction, linearDamping, angularDamping, restitution) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {
                syncData.body.setFriction(friction);
                syncData.body.setDamping(linearDamping, angularDamping);
                syncData.body.setRestitution(restitution);
            }
        }

    });


}


/**
 * Describe this function...
 */
function init_physics() {
  createPhysicsBody('STATIC', 'terrain_navmesh', 'MESH', 1);
  createPhysicsBody('DYNAMIC', 'hunter_physic', 'BOX', 1);
  physicsBodyParams('hunter_physic', 0.9, 0.5, 0.2, 0);
}

/**
 * Describe this function...
 */
function load_amazon_char() {
}

/**
 * Describe this function...
 */
function hide_body_amazon() {
}

/**
 * Describe this function...
 */
function hide_body_hunter() {
}

/**
 * Describe this function...
 */
function show_controls() {
}

/**
 * Describe this function...
 */
function hide_button_startout_game() {
}

/**
 * Describe this function...
 */
function show_main_game_stats() {
}

/**
 * Describe this function...
 */
function show_pick_objs() {
}

/**
 * Describe this function...
 */
function show_game_menu_calling() {
}

/**
 * Describe this function...
 */
function show_progress_bar() {
}

/**
 * Describe this function...
 */
function load_pick_object(hunter_loaded, amazon_loaded) {
}

/**
 * Describe this function...
 */
function hide_form_f01_change_char_menu() {
}


// getEventProperty puzzle
function getEventProperty(prop, event) {
    if (typeof event != "undefined") {
        if (prop == "target.id")
            return event.target.id;
        else
            return event[prop];
    }
}



// eventHTMLElem puzzle
function eventHTMLElem(eventType, ids, isParent, callback) {
    var elems = getElements(ids, isParent);
    for (var i = 0; i < elems.length; i++) {
        var elem = elems[i];
        if (!elem)
            continue;
        elem.addEventListener(eventType, callback, false);
    }
}




function initGetCameraDirection() {
    var coordsCallback = function(event) {
        event.preventDefault();

        var xNorm = 0, yNorm = 0;
        if (event instanceof MouseEvent) {
            xNorm = event.offsetX / elem.clientWidth;
            yNorm = event.offsetY / elem.clientHeight;
        } else if (event instanceof TouchEvent) {
            var rect = elem.getBoundingClientRect();
            xNorm = (event.changedTouches[0].clientX - rect.left) / rect.width;
            yNorm = (event.changedTouches[0].clientY - rect.top) / rect.height;
        }

        _pGlob.screenCoords.x = xNorm * 2 - 1;
        _pGlob.screenCoords.y = -yNorm * 2 + 1;
    }

    var elem = appInstance.container;
    elem.addEventListener('mousemove', coordsCallback);
    elem.addEventListener('mousedown', coordsCallback);
    elem.addEventListener('mouseup', coordsCallback);
    elem.addEventListener('touchstart', coordsCallback);
    elem.addEventListener('touchend', coordsCallback);

};

initGetCameraDirection();




// getCameraDirection puzzle
var getCameraDirection = function() {

    var coords = new v3d.Vector2();
    var raycaster = new v3d.Raycaster();

    return function getCameraDirection(useMouseTouch, inverted) {
        var camera = appInstance.camera;

        if (useMouseTouch) {

            if (inverted) {
                coords.x = -_pGlob.screenCoords.x;
                coords.y = -_pGlob.screenCoords.y;
            } else {
                coords.x = _pGlob.screenCoords.x;
                coords.y = _pGlob.screenCoords.y;
            }

            raycaster.setFromCamera(coords, camera);
            var dir = raycaster.ray.direction;

        } else {
            var dir = camera.getWorldDirection(new v3d.Vector3());
        }

        return [dir.x, -dir.z, dir.y];
    }
}();



// getObjDirection puzzle
function getObjDirection(objName, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;

    var dir = obj.getWorldDirection(new v3d.Vector3());

    switch (coord) {
    case 'X':
        return dir.x;
    case 'Y':
        return -dir.z;
    case 'Z':
        return dir.y;
    case 'XYZ':
        return [dir.x, -dir.z, dir.y];
    default:
        console.error("get object direction: Wrong coords");
        return;
    }
};



// physicsApplyVector puzzle
function physicsApplyVector(type, objNames, x, y, z) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    var vec = swizzleVec3([x, y, z]);

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {

                var btVec = new Ammo.btVector3(vec[0], vec[1], vec[2]);

                switch (type) {
                case 'GRAVITY':
                    syncData.body.setGravity(btVec);
                    break;
                case 'FORCE':
                    syncData.body.applyCentralForce(btVec);
                    break;
                case 'LINEAR_VELOCITY':
                    syncData.body.setLinearVelocity(btVec);
                    break;
                case 'ANGULAR_VELOCITY':
                    syncData.body.setAngularVelocity(btVec);
                    break;
                case 'IMPULSE':
                    syncData.body.applyCentralImpulse(btVec);
                    break;
                case 'TORQUE':
                    syncData.body.applyTorque(btVec);
                    break;
                case 'TORQUE_IMPULSE':
                    syncData.body.applyTorqueImpulse(btVec);
                    break;
                case 'POSITION':
                    _pPhysics.transTmp.setIdentity();
                    _pPhysics.transTmp.setOrigin(btVec);

                    var quat = obj.quaternion;
                    _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

                    syncData.body.setWorldTransform(_pPhysics.transTmp);

                    break;
                }

                Ammo.destroy(btVec);
            }
        }

    });


}



// setObjTransform puzzle
function setObjTransform(objNames, mode, x, y, z, offset) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames) return;

    function setObjProp(obj, prop, val) {
        if (typeof val != "number")
            return;
        if (mode == "rotation")
            val = val * Math.PI/180;
        if (!offset) {
            obj[mode][prop] = val;
        } else {
            if (mode != "scale")
                obj[mode][prop] += val;
            else
                obj[mode][prop] *= val;
        }
    }

    var inVec = swizzleVec3([x,y,z], mode == 'scale');
    x = inVec[0];
    y = inVec[1];
    z = inVec[2];

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        setObjProp(obj, "x", x);
        setObjProp(obj, "y", y);
        setObjProp(obj, "z", z);

        obj.updateMatrixWorld(true);
    }
}


/**
 * Describe this function...
 */
function move_front() {
  camDir = getCameraDirection(true, false);
  charDir = getObjDirection('hunter_physic', 'XYZ');
  if (stat_view_TPS == 1) {
    physicsApplyVector('LINEAR_VELOCITY', 'hunter_physic', charDir[0] * 2, charDir[1] * 2, charDir[2] * 2);
    console.log('estamos corriendo adelante con char2');
  } else if (stat_view_FPS == 1) {
    setObjTransform('Cam_firstperson', 'position', camDir[0] * 0.2, camDir[1] * 0.2, camDir[2] * 0, true);
    console.log('estamos corriendo adelante con la camera');
  }
}


// applyObjLocalTransform puzzle
function applyObjLocalTransform(objNames, mode, x, y, z) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames) return;

    var defValue = mode == "scale" ? 1 : 0;
    if (typeof x != "number") x = defValue;
    if (typeof y != "number") y = defValue;
    if (typeof z != "number") z = defValue;

    var inVec = swizzleVec3([x,y,z], mode == 'scale');

    for (var i = 0; i < objNames.length; i++) {
        var objName = objNames[i];
        if (!objName) continue;

        var obj = getObjectByName(objName);
        if (!obj) continue;

        // don't swizzle values for cameras, their local space happens
        // to be the same as for Blender/Max cameras, bcz their different
        // rest orientation balances difference in coordinate systems
        var useSwizzled = !obj.isCamera;
        var xVal = useSwizzled ? inVec[0] : x;
        var yVal = useSwizzled ? inVec[1] : y;
        var zVal = useSwizzled ? inVec[2] : z;

        switch (mode) {
        case "position":
            if (_pGlob.xrSessionAcquired && obj.isCamera) {
                v3d.WebVRUtils.translateVRCamera(obj, _pGlob.AXIS_X, xVal);
                v3d.WebVRUtils.translateVRCamera(obj, _pGlob.AXIS_Y, yVal);
                v3d.WebVRUtils.translateVRCamera(obj, _pGlob.AXIS_Z, zVal);
            } else {
                obj.translateX(xVal);
                obj.translateY(yVal);
                obj.translateZ(zVal);
            }
            break;
        case "rotation":
            if (_pGlob.xrSessionAcquired && obj.isCamera) {
                v3d.WebVRUtils.rotateVRCamera(obj, _pGlob.AXIS_X, v3d.Math.degToRad(xVal));
                v3d.WebVRUtils.rotateVRCamera(obj, _pGlob.AXIS_Y, v3d.Math.degToRad(yVal));
                v3d.WebVRUtils.rotateVRCamera(obj, _pGlob.AXIS_Z, v3d.Math.degToRad(zVal));
            } else {
                obj.rotateX(v3d.Math.degToRad(xVal));
                obj.rotateY(v3d.Math.degToRad(yVal));
                obj.rotateZ(v3d.Math.degToRad(zVal));
            }
            break;
        case "scale":
            obj.scale.x *= xVal;
            obj.scale.y *= yVal;
            obj.scale.z *= zVal;
            break;
        }

        obj.updateMatrixWorld(true);
    }
}


/**
 * Describe this function...
 */
function giro_left2() {
  if (stat_view_TPS == 1) {
    physicsApplyVector('ANGULAR_VELOCITY', 'hunter_physic', 0, 0, 1);
  } else if (stat_view_FPS == 1) {
    applyObjLocalTransform('Cam_firstperson', 'rotation', 0, cam_rotation_z * 1, 0);
  }
}

/**
 * Describe this function...
 */
function move_right3() {
  if (stat_view_TPS == 1) {
    physicsApplyVector('LINEAR_VELOCITY', 'hunter_physic', -1, 0, 0);
    console.log('va o no move right');
  } else if (stat_view_FPS == 1) {
    console.log('go right FPS');
    setObjTransform('Cam_firstperson', 'position', -0.1, '', '', true);
  }
}

/**
 * Describe this function...
 */
function giro_right2() {
  if (stat_view_TPS == 1) {
    physicsApplyVector('ANGULAR_VELOCITY', 'hunter_physic', 0, 0, -1);
  } else if (stat_view_FPS == 1) {
    applyObjLocalTransform('Cam_firstperson', 'rotation', 0, cam_rotation_z * -1, 0);
  }
}

/**
 * Describe this function...
 */
function move_back() {
  camDir = getCameraDirection(true, false);
  charDir = getObjDirection('hunter_physic', 'XYZ');
  if (stat_view_TPS == 1) {
    physicsApplyVector('LINEAR_VELOCITY', 'hunter_physic', charDir[0] * -2, charDir[1] * -2, charDir[2] * -2);
    console.log('estamos corriendo back con personaje');
  } else if (stat_view_FPS == 1) {
    setObjTransform('Cam_firstperson', 'position', camDir[0] * -0.2, camDir[1] * -0.2, camDir[2] * 0, true);
    console.log('estamos corriendo back con camara');
  }
}

/**
 * Describe this function...
 */
function move_left3() {
  if (stat_view_TPS == 1) {
    physicsApplyVector('LINEAR_VELOCITY', 'hunter_physic', 1, 0, 0);
    console.log('va o no move left');
  } else if (stat_view_FPS == 1) {
    console.log('go left fps');
    setObjTransform('Cam_firstperson', 'position', 0.1, '', '', true);
  }
}


// setActiveCamera puzzle
function setActiveCamera(camName) {
    var camera = getObjectByName(camName);
    if (!camera || !camera.isCamera || appInstance.camera == camera)
        return;
    appInstance.setCamera(camera);
}



// tweenCamera puzzle
function tweenCamera(posObjName, targetObjName, duration, doSlot) {
    if (!targetObjName)
        return;
    if (posObjName)
        var posObj = getObjectByName(posObjName);
    else
        var posObj = appInstance.camera;
    var targetObj = getObjectByName(targetObjName);
    if (!posObj || !targetObj)
        return;

    var wPos = posObj.getWorldPosition(_pGlob.vec3Tmp);
    var wTarget = targetObj.getWorldPosition(_pGlob.vec3Tmp2);

    if (appInstance.controls && appInstance.controls.tween) {
        // orbit and flying cameras
        if (!appInstance.controls.inTween)
            appInstance.controls.tween(wPos, wTarget, duration, doSlot);
    } else { // TODO: static camera, just position it for now
        if (appInstance.camera.parent)
            appInstance.camera.parent.worldToLocal(wPos);
        appInstance.camera.position.copy(wPos);
        appInstance.camera.lookAt(wTarget);
        doSlot();
    }
}



// snapToObject puzzle
function snapToObject(objName, targetObjName) {
    if (!objName || !targetObjName)
        return;
    var obj = getObjectByName(objName);
    var targetObj = getObjectByName(targetObjName);
    if (!obj || !targetObj)
        return;
    obj.copyTransform(targetObj);
    obj.updateMatrixWorld(true);
}



// getObjTransform puzzle
function getObjTransform(objName, mode, coord) {
    if (!objName)
        return;
    var obj = getObjectByName(objName);
    if (!obj)
        return;
    if (mode == "rotation")
        return swizzleValueSign(coord, obj[mode][coord] * 180/Math.PI);
    else if (mode == 'position')
        return swizzleValueSign(coord, obj[mode][coord]);
    else
        return obj[mode][coord];
}



// setInterval puzzle
function registerInterval(timeout, callback) {
    window.setInterval(callback, 1000 * timeout);
}


/**
 * Describe this function...
 */
function char_status() {
  if (stat_giro_left == 1) {
    stat_idle = 0;
    giro_left2();
  } else if (stat_giro_right == 1) {
    stat_idle = 0;
    giro_right2();
  } else if (stat_move_left == 1) {
    stat_idle = 0;
    move_left3();
  } else if (stat_move_right == 1) {
    stat_idle = 0;
    move_right3();
  } else if (stat_mov_front == 1) {
    stat_idle = 0;
    move_front();
  } else if (stat_move_back == 1) {
    stat_idle = 0;
    move_back();
  } else if (stat_jump == 1) {
    stat_idle = 0;
    move_jump2();
  } else {
    stat_idle = 1;
    idle2();
  }
}

/**
 * Describe this function...
 */
function show_body_amazon() {
}

/**
 * Describe this function...
 */
function move_left2() {
}

/**
 * Describe this function...
 */
function move_right2() {
}

/**
 * Describe this function...
 */
function game_finised() {
}

/**
 * Describe this function...
 */
function update_app_vars() {
}

/**
 * Describe this function...
 */
function move_jump2() {
}

/**
 * Describe this function...
 */
function idle2() {
}


// callJSFunction puzzle
function getJSFunction(funcName) {
    var jsFunc = appInstance.ExternalInterface[funcName];
    if (typeof jsFunc == "function")
        return jsFunc;
    else
        return function() {};
}



// removePhysicsBody puzzle
function removePhysicsBody(objNames) {

    objNames = retrieveObjectNames(objNames);
    if (!objNames)
        return;

    objNames.forEach(function(objName) {
        if (!objName)
            return;

        var obj = getObjectByName(objName);
        if (!obj)
            return;

        for (var i = 0; i < _pPhysics.syncList.length; i++) {
            var syncData = _pPhysics.syncList[i];

            if (syncData.obj == obj) {
                _pPhysics.world.removeRigidBody(syncData.body);
                Ammo.destroy(syncData.body);
                _pPhysics.syncList.splice(i, 1);
                i--;
            }
        }

    });


}


/**
 * Describe this function...
 */
function Go_ORBIT_TPS() {
  console.log('se ha dado el click sobre orbit');
  if (stat_view_TPS == 1 && stat_view_orbit == 0 && stat_view_FPS == 0) {
    setActiveCamera('Cam_orbit');
    if (is_selected_char_hunter) {
      show_body_hunter();
    } else if (is_selected_char_amazon) {
      show_body_amazon();
    }
    stat_view_orbit = 1;
    console.log('Se ha camabiado camara a  ORBIT! desde TPS');
    stat_view_TPS = 0;
    console.log('luego mantenemos su estado 1 asimilado ');
    console.log('y no lo cambiamos');
  } else if (stat_view_FPS == 1 && (stat_view_orbit == 0 || stat_view_TPS == 0)) {
    setActiveCamera('Cam_orbit');
    if (is_selected_char_hunter) {
      show_body_hunter();
    } else if (is_selected_char_amazon) {
      show_body_amazon();
    }
    hide_body_hunter_fps();
    stat_view_orbit = 1;
    console.log('Se ha camabiado camara a  ORBIT! desde FPS');
    stat_view_FPS = 0;
    view = 'FPS';
    stat_view = stat_view_FPS;
    getJSFunction('set_stat_view')(stat_view, view);
    stat_view_TPS = 1;
    view = 'TPS';
    stat_view = stat_view_TPS;
    getJSFunction('set_stat_view')(stat_view, view);
    removePhysicsBody('hunter_physic');
    snapToObject('hunter_physic', 'pos_FPS');
    createPhysicsBody('DYNAMIC', 'hunter_physic', 'BOX', 1);
    physicsBodyParams('hunter_physic', 0.9, 0.5, 0.2, 0);
  }
  hide_controls_touch1();
}


// distanceBetweenObjects puzzle
function getDistanceBetweenObjects(objName1, objName2) {
    if (!objName1 || !objName2)
        return;
    var obj1 = getObjectByName(objName1);
    var obj2 = getObjectByName(objName2);
    if (!obj1 || !obj2)
        return;
    return obj1.getWorldPosition(_pGlob.vec3Tmp).distanceTo(obj2.getWorldPosition(_pGlob.vec3Tmp2));
}



// everyFrame puzzle
function registerEveryFrame(callback) {
    if (typeof callback == "function")
        appInstance.renderCallbacks.push(callback);
}


/**
 * Describe this function...
 */
function show_body_hunter() {
}

/**
 * Describe this function...
 */
function hide_body_hunter_fps() {
}

/**
 * Describe this function...
 */
function hide_controls_touch1() {
}


// isAnimationPlaying puzzle
function isAnimationPlaying(animations) {
    if (!animations)
        return;
    // input can be either single obj or array of objects
    if (typeof animations == "string")
        animations = [animations];
    for (var i = 0; i < animations.length; i++) {
        var animName = animations[i];
        if (!animName)
            continue;
        var action = v3d.SceneUtils.getAnimationActionByName(appInstance, animName);
        if (action && action.isRunning())
            return true;
    }
    return false;
}


/**
 * Describe this function...
 */
function change_char_menu() {
}

/**
 * Describe this function...
 */
function cheats_menu() {
}

/**
 * Describe this function...
 */
function Go_TPS() {
  if (stat_view_FPS == 1 && (stat_view_orbit == 0 || stat_view_TPS == 0)) {
    setActiveCamera('Cam_down_ctrl');
    removePhysicsBody('hunter_physic');
    snapToObject('hunter_physic', 'pos_FPS');
    createPhysicsBody('DYNAMIC', 'hunter_physic', 'BOX', 1);
    physicsBodyParams('hunter_physic', 0.8, 0.5, 0.2, 0);
    stat_view_TPS = 1;
    console.log('Se ha camabiado a camara TPS! desde FPS');
    stat_view_FPS = 0;
    view = 'FPS';
    stat_view = stat_view_FPS;
    getJSFunction('set_stat_view')(stat_view, view);
    hide_body_hunter_fps();
  } else if (stat_view_FPS == 0 && (stat_view_TPS == 1 || stat_view_orbit == 1)) {
    setActiveCamera('Cam_down_ctrl');
    stat_view_TPS = 1;
    console.log('Se ha camabiado camara a TPS! desde ORBIT');
    stat_view_orbit = 0;
    view = 'orbit';
    stat_view = stat_view_orbit;
    getJSFunction('set_stat_view')(stat_view, view);
    if (is_selected_char_hunter) {
      show_body_hunter();
    } else if (is_selected_char_amazon) {
      show_body_amazon();
    }
    console.log('al venir de FPS debemos mostrar en tps los avatares');
  }
  console.log('el statdo tps  deberia ser 1 y es ');
  console.log(stat_view_TPS);
  view = 'TPS';
  stat_view = stat_view_TPS;
  getJSFunction('set_stat_view')(stat_view, view);
  hide_controls_touch1();
}


// setTimeout puzzle
function registerSetTimeout(timeout, callback) {
    window.setTimeout(callback, 1000 * timeout);
}



function objectTreeFilterUnload(rootObj, filterFun) {
    var objsToUnload = [];

    (function traverse(obj) {
        if (filterFun(obj)) {
            objsToUnload.push(obj);
            return;
        }
        obj.children.forEach(function(child) { traverse(child); });
    })(rootObj);

    objsToUnload.forEach(function(obj) { appInstance.unload(obj); });
}


// appendScene puzzle
function appendScene(url, loadCameras, loadLights, loadCb, progCb) {
    _pGlob.percentage = 0;

    appInstance.appendScene(url, function(loadedScene) {

        if (!loadCameras || !loadLights) {
            objectTreeFilterUnload(loadedScene, function(obj) {
                return obj.isCamera && !loadCameras || obj.isLight && !loadLights;
            });
        }
        loadedScene.name = url;

        _pGlob.percentage = 100;
        loadCb();
    }, function(percentage) {
        _pGlob.percentage = percentage;
        progCb();
    }, null);
}



// unloadScene puzzle
function unloadScene(url) {
    if (appInstance.scene) {
        var scene = url === '' ? appInstance.scene : appInstance.scene.getObjectByName(url);
        if (scene) appInstance.unload(scene);

        if (!appInstance.scene) appInstance.renderer.clear();

        // clean object cache
        _pGlob.objCache = {};
    }
}


/**
 * Describe this function...
 */
function load_hunter_char2() {
  if (!hunter_loaded) {
    appendScene('assets/characters/heroe/heroe.gltf', true, true, function() {
      console.log('se cargo thehunter scena');
      hunter_loaded = 1;
      console.log('hunter_loaded_es 1');
      registerSetTimeout(3, function() {
        setHTMLElemStyle('display', 'none', 'Progress_Bar', true);
      });
    }, function() {
      show_progress_bar();
    });
  } else if (amazon_loaded) {
    unloadScene('assets/characters/amazon/amazon.gltf.xz');
    amazon_loaded = 0;
    console.log('amazon_loaded_es 0');
    console.log('se descargo scena amazon char');
  }
  console.log('antes de aplicar la fisica personaje esta en');
  console.log(getObjTransform('hunter_physic', 'position', 'y'));
  if (!current_level_loaded) {
    if (current_level == 'level_city') {
      current_level_index = 0;
    } else if (current_level == 'level_campo') {
      current_level_index = 1;
    }
    appendScene(level_path[current_level_index], true, true, function() {
      current_level_loaded = 1;
      stat_view_TPS = 1;
      level_parameters();
      play_music_level();
      stat_game_paused = 1;
      setActiveCamera('Cam_down_ctrl');
      tweenCamera('', 'camera_target', 1, function() {});
      show_run_tool();
    }, function() {
      show_progress_bar();
    });
  }
}

/**
 * Describe this function...
 */
function level_parameters() {
  init_physics();
}

/**
 * Describe this function...
 */
function play_music_level() {
}

/**
 * Describe this function...
 */
function show_run_tool() {
}

/**
 * Describe this function...
 */
function restore_pos_char(person_position_X, person_position_Y, person_position_Z) {
}


list_var_main1();
list_var_main2();
main_game();



// HACK
if (typeof window.Ammo == 'function') {
    window.Ammo().then(function(Ammo) {
        window.Ammo = Ammo;
    });
}

// createPhysicsWorld puzzle
_pPhysics.collisionConfiguration = new Ammo.btDefaultCollisionConfiguration();
_pPhysics.dispatcher = new Ammo.btCollisionDispatcher(_pPhysics.collisionConfiguration);
_pPhysics.broadphase = new Ammo.btDbvtBroadphase();
_pPhysics.solver = new Ammo.btSequentialImpulseConstraintSolver();
_pPhysics.world = new Ammo.btDiscreteDynamicsWorld(_pPhysics.dispatcher,
        _pPhysics.broadphase, _pPhysics.solver, _pPhysics.collisionConfiguration);
_pPhysics.world.setGravity( new Ammo.btVector3( 0, -9.8, 0 ) );
_pPhysics.fps = 120;
_pPhysics.transTmp = new Ammo.btTransform();

function tick(dt) {
    var DISABLE_DEACTIVATION = 4;
    var DISTANCE_EPSILON = 0.000001;

    if (_pPhysics.collisionData.length) {

        var numManifolds = _pPhysics.world.getDispatcher().getNumManifolds();

        for (var i = 0; i < numManifolds; i++) {
            var contactManifold = _pPhysics.world.getDispatcher().getManifoldByIndexInternal(i);

            var bodyA = Ammo.castObject(contactManifold.getBody0(), Ammo.btRigidBody);
            var bodyB = Ammo.castObject(contactManifold.getBody1(), Ammo.btRigidBody);

            var collDataMatch = null;
            var objsSwapped = false;

            for (var j = 0; j < _pPhysics.collisionData.length; j++) {
                var cd = _pPhysics.collisionData[j];

                if (cd.bodyA == bodyA && cd.bodyB == bodyB) {
                    collDataMatch = cd;
                    break;
                }

                if (cd.bodyA == bodyB && cd.bodyB == bodyA) {
                    collDataMatch = cd;
                    objsSwapped = true;
                    break;
                }
            }

            if (!collDataMatch)
                continue;

            var numContacts = contactManifold.getNumContacts();

            for (var j = 0; j < numContacts; j++) {
                var pt = contactManifold.getContactPoint(j);

                if (pt.getDistance() < DISTANCE_EPSILON) {
                    var ptA = pt.getPositionWorldOnA();
                    var ptB = pt.getPositionWorldOnB();
                    var noB = pt.get_m_normalWorldOnB();

                    _pPhysics.collisionInfo.objectA = collDataMatch.objA ? getPickedObjectName(collDataMatch.objA) : '';
                    _pPhysics.collisionInfo.objectB = collDataMatch.objB ? getPickedObjectName(collDataMatch.objB) : '';

                    _pPhysics.collisionInfo.distance = pt.getDistance();

                    if (!objsSwapped) {
                        _pPhysics.collisionInfo.positionOnA[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptA.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptB.z();

                        _pPhysics.collisionInfo.normalOnB[0] = noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = noB.z();
                    } else {
                        _pPhysics.collisionInfo.positionOnA[0] = ptB.x();
                        _pPhysics.collisionInfo.positionOnA[1] = ptB.y();
                        _pPhysics.collisionInfo.positionOnA[2] = ptB.z();

                        _pPhysics.collisionInfo.positionOnB[0] = ptA.x();
                        _pPhysics.collisionInfo.positionOnB[1] = ptA.y();
                        _pPhysics.collisionInfo.positionOnB[2] = ptA.z();

                        _pPhysics.collisionInfo.normalOnB[0] = -noB.x();
                        _pPhysics.collisionInfo.normalOnB[1] = -noB.y();
                        _pPhysics.collisionInfo.normalOnB[2] = -noB.z();
                    }

                    collDataMatch.collideCb();
                    collDataMatch.collideFlag = true;
                }
            }
        }

        for (var i = 0; i < _pPhysics.collisionData.length; i++) {
            var cd = _pPhysics.collisionData[i];

            if (!cd.collideFlag) {
                _pPhysics.collisionInfo.objectA = '';
                _pPhysics.collisionInfo.objectB = '';

                _pPhysics.collisionInfo.distance = 0;

                _pPhysics.collisionInfo.positionOnA[0] = 0;
                _pPhysics.collisionInfo.positionOnA[1] = 0;
                _pPhysics.collisionInfo.positionOnA[2] = 0;

                _pPhysics.collisionInfo.positionOnB[0] = 0;
                _pPhysics.collisionInfo.positionOnB[1] = 0;
                _pPhysics.collisionInfo.positionOnB[2] = 0;

                _pPhysics.collisionInfo.normalOnB[0] = 0;
                _pPhysics.collisionInfo.normalOnB[1] = 0;
                _pPhysics.collisionInfo.normalOnB[2] = 0;

                cd.noCollideCb();
            }

            cd.collideFlag = false;
        }
    }

    _pPhysics.world.stepSimulation(dt, 10, 1/120);

    // sync physics and graphics

    for (var i = 0; i < _pPhysics.syncList.length; i++) {
        var syncData = _pPhysics.syncList[i];

        if (syncData.type == 'DYNAMIC') {
            syncData.body.setActivationState(DISABLE_DEACTIVATION);

            var ms = syncData.body.getMotionState();
            if (ms) {
                ms.getWorldTransform(_pPhysics.transTmp);
                var p = _pPhysics.transTmp.getOrigin();
                var q = _pPhysics.transTmp.getRotation();
                // dynamic objects can't be parented to something
                syncData.obj.position.set(p.x(), p.y(), p.z());
                syncData.obj.quaternion.set(q.x(), q.y(), q.z(), q.w());
            }

        } else if (syncData.type == 'KINEMATIC') {

            var pos = syncData.obj.getWorldPosition(_pGlob.vec3Tmp);
            var quat = syncData.obj.getWorldQuaternion(_pGlob.quatTmp);

            _pPhysics.transTmp.setIdentity();
            _pPhysics.transTmp.setOrigin(new Ammo.btVector3(pos.x, pos.y, pos.z));
            _pPhysics.transTmp.setRotation(new Ammo.btQuaternion(quat.x, quat.y, quat.z, quat.w));

            syncData.body.setWorldTransform(_pPhysics.transTmp);

        }
    }

}

appInstance.renderCallbacks.push(tick);


eventHTMLElem('keydown', ['BODY'], false, function(event) {
  if (start_game) {
    if ((getEventProperty('key', event) == 'ArrowLeft' || getEventProperty('key', event) == 'a') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('go left!');
      stat_move_left = 1;
    } else if ((getEventProperty('key', event) == 'ArrowRight' || getEventProperty('key', event) == 'd') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('go right!');
      stat_move_right = 1;
    } else if (getEventProperty('key', event) == 'Enter' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      if (stat_jump == 0) {
        stat_jump = 1;
      }
    } else if ((getEventProperty('key', event) == 'w' || getEventProperty('key', event) == 'ArrowUp') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('front');
      stat_mov_front = 1;
    } else if ((getEventProperty('key', event) == 'ArrowDown' || getEventProperty('key', event) == 's') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('Back');
      stat_move_back = 1;
    } else if (getEventProperty('key', event) == 'q' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('Giro_Left!');
      stat_giro_left = 1;
    } else if (getEventProperty('key', event) == 'e' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('Giro_Right!');
      stat_giro_right = 1;
    } else if (getEventProperty('key', event) == '1' && stat_view_orbit) {
      Go_TPS();
    } else if (getEventProperty('key', event) == '2' && stat_view_TPS) {
      Go_ORBIT_TPS();
    }
  }
});

eventHTMLElem('keyup', ['BODY'], false, function(event) {
  if (start_game) {
    if ((getEventProperty('key', event) == 'ArrowLeft' || getEventProperty('key', event) == 'a') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('go left up!');
      stat_move_left = 0;
    } else if ((getEventProperty('key', event) == 'ArrowRight' || getEventProperty('key', event) == 'd') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('go right up!');
      stat_move_right = 0;
    } else if (getEventProperty('key', event) == 'Enter' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      stat_jump = 0;
    } else if ((getEventProperty('key', event) == 'ArrowUp' || getEventProperty('key', event) == 'w') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('front up!');
      stat_mov_front = 0;
    } else if ((getEventProperty('key', event) == 'ArrowDown' || getEventProperty('key', event) == 's') && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      console.log('Back up!');
      stat_move_back = 0;
    } else if (getEventProperty('key', event) == 'q' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      stat_giro_left = 0;
    } else if (getEventProperty('key', event) == 'e' && (stat_view_FPS == 1 || stat_view_TPS == 1)) {
      stat_giro_right = 0;
    }
  }
});

registerInterval(1, function() {
  if (stat_view_TPS == 1 && stat_view_FPS == 0 && stat_view_orbit == 0) {
    setActiveCamera('Cam_down_ctrl');
    tweenCamera('', 'camera_target', 1, function() {});
    show_body_hunter();
    hide_body_hunter_fps();
  } else if (stat_view_orbit == 1) {
    setActiveCamera('Cam_orbit');
    tweenCamera('', 'camera_target', 1, function() {});
  }
  if (stat_change_char) {
    setActiveCamera('camera_low_scene');
    tweenCamera('', 'pivot_change_char', 1, function() {});
    change_char_menu();
  }
  if (stat_cheats_menu) {
    cheats_menu();
  }
  if (stat_change_char) {
    setActiveCamera('camera_low_scene');
  }
  if (stat_view_FPS) {
    setActiveCamera('Cam_firstperson');
    snapToObject('Cam_firstperson2', 'Cam_firstperson');
  }
  if (!stat_jump && stat_view_FPS) {
    current_pos_Z_fps = getObjTransform('Cam_firstperson2', 'position', 'y');
    if (!stat_en_pte && current_pos_Z_fps > 0.48) {
      stat_en_pte = 1;
      cam_pos_z_max = cam_pos_z_min + 5;
      cam_pos_z_min = getObjTransform('Cam_firstperson2', 'position', 'y');
      console.log('creo que deberiamos ver que estamos en pte');
    } else {
      stat_en_pte = 0;
    }
  }
});

registerEveryFrame(function() {
  if (start_game) {
    char_status();
    setObjTransform('fondo', 'rotation', '', '', 0.03, true);
    for (j = 1; j <= 9; j++) {
      emptys_to_check = String('Empty.00') + String(j);
      if (stat_view_TPS || stat_view_orbit) {
        emptys_distance[j] = getDistanceBetweenObjects('character_picker', emptys_to_check);
      } else if (stat_view_FPS) {
        emptys_distance[j] = getDistanceBetweenObjects('Cam_firstperson', emptys_to_check);
      }
    }
    for (j = 10; j <= 11; j++) {
      emptys_to_check = String('Empty.0') + String(j);
      if (stat_view_TPS || stat_view_orbit) {
        emptys_distance[j] = getDistanceBetweenObjects('character_picker', emptys_to_check);
      } else if (stat_view_FPS) {
        emptys_distance[j] = getDistanceBetweenObjects('Cam_firstperson', emptys_to_check);
      }
    }
  }
});

registerEveryFrame(function() {
  if (stat_mov_front == 0 && stat_move_back == 0 && start_game && isAnimationPlaying('hunter_rig')) {

    operateAnimation('STOP', 'hunter_rig', null, null, 'AUTO', 1,
            function() {}, undefined, false);

        }
  if (stat_mov_front == 1 && !isAnimationPlaying('hunter_rig')) {

    operateAnimation('PLAY', 'hunter_rig', null, null, 'LoopOnce', 1,
            function() {}, undefined, false);

        } else if (stat_move_back == 1 && !isAnimationPlaying('hunter_rig')) {

    operateAnimation('PLAY', 'hunter_rig', null, null, 'LoopOnce', 1,
            function() {}, undefined, false);

        }
});

} // end of PL.init function

if (window.v3dApp) {
    // backwards compatibility for old player projects
    PL.legacyMode = true;
    PL.init(window.v3dApp);
}

})(); // end of closure

/* ================================ end of code ============================= */
